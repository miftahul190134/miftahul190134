{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tentang Biodata Nama : Moch. Miftahul Huda F. NIM : 190411100134 Kelas : Komputasi Numerik C Dosen : MULA'AB, S.Si., M.Kom Komputasi Numerik Komputasi numerik merupakan metode numerik yang memanfaatkan bahasa pemrograman komputer untuk melakukan iterasi perhitungan numerik yang tidak dapat diselesaikan secara manual Note Konten diupdate berdasarkan tugas tes","title":"Tentang"},{"location":"#tentang","text":"","title":"Tentang"},{"location":"#biodata","text":"Nama : Moch. Miftahul Huda F. NIM : 190411100134 Kelas : Komputasi Numerik C Dosen : MULA'AB, S.Si., M.Kom","title":"Biodata"},{"location":"#komputasi-numerik","text":"Komputasi numerik merupakan metode numerik yang memanfaatkan bahasa pemrograman komputer untuk melakukan iterasi perhitungan numerik yang tidak dapat diselesaikan secara manual Note Konten diupdate berdasarkan tugas tes","title":"Komputasi Numerik"},{"location":"diferensial/1.%20teori/","text":"Teori Persamaan Diferensial Biasa Persamaan diferensial biasa adalah persamaan diferensial dimana fungsi yang tidak diketahui (variabel terikat) adalah fungsi dari variabel bebas tunggal. Persamaan diferensial adalah gabungan antara fungsi yang tidak diketahui secara eksplisit dan turunan (diferensial)-nya. 1 Metode Euler Metode Euler merupakan metode paling sederhana yang diturunkan dari deret Taylor. Namun, meskipun sederhana, metode ini masih kurang teliti untuk menghitung persamaan yang banyak. Referensi Wikipedia Persamaan diferensial biasa \u21a9","title":"Teori"},{"location":"diferensial/1.%20teori/#teori","text":"","title":"Teori"},{"location":"diferensial/1.%20teori/#persamaan-diferensial-biasa","text":"Persamaan diferensial biasa adalah persamaan diferensial dimana fungsi yang tidak diketahui (variabel terikat) adalah fungsi dari variabel bebas tunggal. Persamaan diferensial adalah gabungan antara fungsi yang tidak diketahui secara eksplisit dan turunan (diferensial)-nya. 1","title":"Persamaan Diferensial Biasa"},{"location":"diferensial/1.%20teori/#metode-euler","text":"Metode Euler merupakan metode paling sederhana yang diturunkan dari deret Taylor. Namun, meskipun sederhana, metode ini masih kurang teliti untuk menghitung persamaan yang banyak.","title":"Metode Euler"},{"location":"diferensial/1.%20teori/#referensi","text":"Wikipedia Persamaan diferensial biasa \u21a9","title":"Referensi"},{"location":"diferensial/2.%20algoritma/","text":"Metode Persamaan Diferensial Biasa Metode Eulier Menghitung hampiran penyelesaian masalah nilai awal y' = f (t, y) dengan y(t0) = y0 pada [t0,b] Input : n, t0, b, y0, dan fungsi f Output : (tk, yk), k = 1, 2, ...; n Algoritma Menentukan nilai x0 dan y0. Nenentukan nilai h yang digunakan. Menentukan banyak iterasi (n). Melakukan penghitungan menggunakan persamaan diatas.","title":"Algoritma"},{"location":"diferensial/2.%20algoritma/#metode-persamaan-diferensial-biasa","text":"","title":"Metode Persamaan Diferensial Biasa"},{"location":"diferensial/2.%20algoritma/#metode-eulier","text":"Menghitung hampiran penyelesaian masalah nilai awal y' = f (t, y) dengan y(t0) = y0 pada [t0,b] Input : n, t0, b, y0, dan fungsi f Output : (tk, yk), k = 1, 2, ...; n","title":"Metode Eulier"},{"location":"diferensial/2.%20algoritma/#algoritma","text":"Menentukan nilai x0 dan y0. Nenentukan nilai h yang digunakan. Menentukan banyak iterasi (n). Melakukan penghitungan menggunakan persamaan diatas.","title":"Algoritma"},{"location":"diferensial/3.%20kode/","text":"Metode Persamaan Diferensial Biasa Metode Eulier Kode Cari persoalan berikut dengan metode eulier: \\[ \\dfrac{dy}{dx}=1+x^2, \\ \\ \\ y(1)= -10 \\] untuk menentukan y(1.01), y(1.02) dan y(1.03). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # metode euler x1 = float ( input ( \"Masukkan x1= \" )) x2 = float ( input ( \"Masukkan x2= \" )) n = int ( input ( \"masukkan jumlah iterasi= \" )) n += 1 h = 1.01 - x1 xi = - 10 hasil = x y = 0 for i in range ( n ): print ( \"hasil dari y\" + str ( i ) + \"= \" + str ( hasil )) hasil = xi + h * ( 1 + ( x1 + y ) ** 2 ) y += h xi = hasil Output 1 2 3 4 5 6 7 Masukkan x1= 1 Masukkan x2= 1 masukkan jumlah iterasi= 3 hasil dari y0= -10 hasil dari y1= -9.98 hasil dari y2= -9.959799 hasil dari y3= -9.939395000000001","title":"Kode"},{"location":"diferensial/3.%20kode/#metode-persamaan-diferensial-biasa","text":"","title":"Metode Persamaan Diferensial Biasa"},{"location":"diferensial/3.%20kode/#metode-eulier","text":"","title":"Metode Eulier"},{"location":"diferensial/3.%20kode/#kode","text":"Cari persoalan berikut dengan metode eulier: \\[ \\dfrac{dy}{dx}=1+x^2, \\ \\ \\ y(1)= -10 \\] untuk menentukan y(1.01), y(1.02) dan y(1.03). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # metode euler x1 = float ( input ( \"Masukkan x1= \" )) x2 = float ( input ( \"Masukkan x2= \" )) n = int ( input ( \"masukkan jumlah iterasi= \" )) n += 1 h = 1.01 - x1 xi = - 10 hasil = x y = 0 for i in range ( n ): print ( \"hasil dari y\" + str ( i ) + \"= \" + str ( hasil )) hasil = xi + h * ( 1 + ( x1 + y ) ** 2 ) y += h xi = hasil","title":"Kode"},{"location":"diferensial/3.%20kode/#output","text":"1 2 3 4 5 6 7 Masukkan x1= 1 Masukkan x2= 1 masukkan jumlah iterasi= 3 hasil dari y0= -10 hasil dari y1= -9.98 hasil dari y2= -9.959799 hasil dari y3= -9.939395000000001","title":"Output"},{"location":"sistem-persamaan-linear/1.%20teori/","text":"Teori Sistem Persamaan Linear Aljabar linear adalah bidang studi matematika yang mempelajari sistem persamaan linear dan solusinya, vektor, dan transformasi linear. Aljabar linear sangat diperlukan dalam berbagai bidang seperti fisika, kimia, komputer, ekonomi, dan sebagainya. 1 Persamaan Linear merupakan sebuah persamaan aljabar yang ditulis dengan tanda sama dengan (=) dan memiliki beberapa variabel minimal 1. 2 Dibawah ini merupakan bentuk umum dari SPL (Sistem Persamaan Linear) \\[ \\displaylines{ a_{11}x_{1}+a_{12}x_{2}+...+a_{1n}x_{n} = b1 \\\\ a_{21}x_{1}+a_{22}x_{2}+...+a_{2n}x_{n} = b2 \\\\ a_{31}x_{1}+a_{32}x_{2}+...+a_{3n}x_{n} = b3 \\\\ \\vdots \\\\ a_{n1}x_{1}+a_{n2}x_{2}+...+a_{2nn}x_{n} = bn \\\\ } \\] Sistem Persamaan Linear Numerik Sistem persamaan linear yang tidak dapat diselesaikan dengan metode analitik dapat diselesaikan dengan beberapa algoritma berikut, Metode Eliminasi Gauss Metode Jacobi Metode Gauss Seidel Referensi Wikipedia Aljabar Linear \u21a9 Wikipedia Persamaan Linear \u21a9","title":"Teori"},{"location":"sistem-persamaan-linear/1.%20teori/#teori","text":"","title":"Teori"},{"location":"sistem-persamaan-linear/1.%20teori/#sistem-persamaan-linear","text":"Aljabar linear adalah bidang studi matematika yang mempelajari sistem persamaan linear dan solusinya, vektor, dan transformasi linear. Aljabar linear sangat diperlukan dalam berbagai bidang seperti fisika, kimia, komputer, ekonomi, dan sebagainya. 1 Persamaan Linear merupakan sebuah persamaan aljabar yang ditulis dengan tanda sama dengan (=) dan memiliki beberapa variabel minimal 1. 2 Dibawah ini merupakan bentuk umum dari SPL (Sistem Persamaan Linear) \\[ \\displaylines{ a_{11}x_{1}+a_{12}x_{2}+...+a_{1n}x_{n} = b1 \\\\ a_{21}x_{1}+a_{22}x_{2}+...+a_{2n}x_{n} = b2 \\\\ a_{31}x_{1}+a_{32}x_{2}+...+a_{3n}x_{n} = b3 \\\\ \\vdots \\\\ a_{n1}x_{1}+a_{n2}x_{2}+...+a_{2nn}x_{n} = bn \\\\ } \\]","title":"Sistem Persamaan Linear"},{"location":"sistem-persamaan-linear/1.%20teori/#sistem-persamaan-linear-numerik","text":"Sistem persamaan linear yang tidak dapat diselesaikan dengan metode analitik dapat diselesaikan dengan beberapa algoritma berikut, Metode Eliminasi Gauss Metode Jacobi Metode Gauss Seidel","title":"Sistem Persamaan Linear Numerik"},{"location":"sistem-persamaan-linear/1.%20teori/#referensi","text":"Wikipedia Aljabar Linear \u21a9 Wikipedia Persamaan Linear \u21a9","title":"Referensi"},{"location":"sistem-persamaan-linear/2.%20algoritma/","text":"Metode Penyelesaian SPL Numerik Metode Eliminasi Gauss Eliminasi Gauss adalah metode yang dikembangkan dari metode eliminasi yang digunakan untuk mengoperasikan nilai-nilai pada matrix sehingga menjadi matrix yang lebih simple. Metode Eliminasi Gauss mengubah matrix dengan menggunakan operasi baris elementer (OBE) yang mengubah matrix menjadi segitiga atas / segitiga bawah. 1 Untuk menghitung dengan metode eliminasi gauss dapat menggunakan 2 langkah antara lain: Eliminasi Maju (Forward Elimination) Substitusi Mundur (Backward Substitution) Algoritma Menentukan persamaan yang akan dicari Masukkan matrix a & matrix b Melakukan perhitungan dengan eliminasi maju (membuat segitiga atas) Melakukan perhitungan dengan substitusi mundur Menampilkan hasilnya Metode Jacobi Metode Jacobi adalah metode yang dapat menyelesaikan sistem persamaan linear berdimensi banyak (lebih dari 2). Metode Jacobi tidak menggunakan hasil nilai terkini dibandingkan dengan metode gauss siedel. 2 Rumus dari metode Jacobi : \\[ x_{i}^{\\left( k+1\\right) }=\\left( b_{i}-\\sum ^{i-1}_{j=1}a_{ij}x_{j}^{k}-\\sum ^{n}_{j=i+1}a_{ij}x_{j}^{k}\\right) /aii , k= 1,2,...,n \\] Algoritma Menentukan persamaan yang akan dicari Menyusun berdasarkan diagonal yang paling besar Swap dengan persamaan b Looping sampai dengan kondisi toleransi error terpenuhi tanpa menyimpan hasil nilai terkini Metode Gauss Siedel Metode Gauss Siedel sama dengan metode Jacobi, perbedaannya adalah metode ini menggunakan hasil terkini untuk menghitung iterasi selanjutnya Rumus dari metode Gauss Siedel : \\[ x_{i}^{\\left( k+1\\right) }=\\left( b_{i}-\\sum ^{i-1}_{j=1}a_{ij}x_{j}^{k+1}-\\sum ^{n}_{j=i+1}a_{ij}x_{j}^{k}\\right) /aii , k= 1,2,...,n \\] Algoritma Menentukan persamaan yang akan dicari Menyusun berdasarkan diagonal yang paling besar Swap dengan persamaan b Looping sampai dengan kondisi toleransi error terpenuhi dengan menyimpan hasil nilai terkini Referensi Metode numerik: penyelesaian persamaan linier, Eliminasi Gauss , eliminasi gauss Jhordan \u21a9 Wikipedia Metode Jacobi \u21a9","title":"Algoritma"},{"location":"sistem-persamaan-linear/2.%20algoritma/#metode-penyelesaian-spl-numerik","text":"","title":"Metode Penyelesaian SPL Numerik"},{"location":"sistem-persamaan-linear/2.%20algoritma/#metode-eliminasi-gauss","text":"Eliminasi Gauss adalah metode yang dikembangkan dari metode eliminasi yang digunakan untuk mengoperasikan nilai-nilai pada matrix sehingga menjadi matrix yang lebih simple. Metode Eliminasi Gauss mengubah matrix dengan menggunakan operasi baris elementer (OBE) yang mengubah matrix menjadi segitiga atas / segitiga bawah. 1 Untuk menghitung dengan metode eliminasi gauss dapat menggunakan 2 langkah antara lain: Eliminasi Maju (Forward Elimination) Substitusi Mundur (Backward Substitution)","title":"Metode Eliminasi Gauss"},{"location":"sistem-persamaan-linear/2.%20algoritma/#algoritma","text":"Menentukan persamaan yang akan dicari Masukkan matrix a & matrix b Melakukan perhitungan dengan eliminasi maju (membuat segitiga atas) Melakukan perhitungan dengan substitusi mundur Menampilkan hasilnya","title":"Algoritma"},{"location":"sistem-persamaan-linear/2.%20algoritma/#metode-jacobi","text":"Metode Jacobi adalah metode yang dapat menyelesaikan sistem persamaan linear berdimensi banyak (lebih dari 2). Metode Jacobi tidak menggunakan hasil nilai terkini dibandingkan dengan metode gauss siedel. 2 Rumus dari metode Jacobi : \\[ x_{i}^{\\left( k+1\\right) }=\\left( b_{i}-\\sum ^{i-1}_{j=1}a_{ij}x_{j}^{k}-\\sum ^{n}_{j=i+1}a_{ij}x_{j}^{k}\\right) /aii , k= 1,2,...,n \\]","title":"Metode Jacobi"},{"location":"sistem-persamaan-linear/2.%20algoritma/#algoritma_1","text":"Menentukan persamaan yang akan dicari Menyusun berdasarkan diagonal yang paling besar Swap dengan persamaan b Looping sampai dengan kondisi toleransi error terpenuhi tanpa menyimpan hasil nilai terkini","title":"Algoritma"},{"location":"sistem-persamaan-linear/2.%20algoritma/#metode-gauss-siedel","text":"Metode Gauss Siedel sama dengan metode Jacobi, perbedaannya adalah metode ini menggunakan hasil terkini untuk menghitung iterasi selanjutnya Rumus dari metode Gauss Siedel : \\[ x_{i}^{\\left( k+1\\right) }=\\left( b_{i}-\\sum ^{i-1}_{j=1}a_{ij}x_{j}^{k+1}-\\sum ^{n}_{j=i+1}a_{ij}x_{j}^{k}\\right) /aii , k= 1,2,...,n \\]","title":"Metode Gauss Siedel"},{"location":"sistem-persamaan-linear/2.%20algoritma/#algoritma_2","text":"Menentukan persamaan yang akan dicari Menyusun berdasarkan diagonal yang paling besar Swap dengan persamaan b Looping sampai dengan kondisi toleransi error terpenuhi dengan menyimpan hasil nilai terkini","title":"Algoritma"},{"location":"sistem-persamaan-linear/2.%20algoritma/#referensi","text":"Metode numerik: penyelesaian persamaan linier, Eliminasi Gauss , eliminasi gauss Jhordan \u21a9 Wikipedia Metode Jacobi \u21a9","title":"Referensi"},{"location":"sistem-persamaan-linear/3.%20kode/","text":"Metode Penyelesaian SPL Numerik Metode Eliminasi Gauss Kode Misalkan ini adalah persamaan yang akan dicari \\[ \\displaylines{ \ud835\udc4e+2\ud835\udc4f+3\ud835\udc50=9 \\\\ 5\ud835\udc4e+2\ud835\udc4f+10\ud835\udc50=20 \\\\ \ud835\udc4e\u22122\ud835\udc4f+5\ud835\udc50=10 } \\] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 matrix_a = [ [ 1 , 2 , 3 ], [ 5 , 2 , 10 ], [ 1 , - 2 , 5 ] ] matrix_b = [ 9 , 20 , 10 ] import numpy from numpy import array , zeros a = array ( matrix_a , float ) b = array ( matrix_b , float ) n = len ( b ) x = zeros ( n , float ) # Forward for k in range ( n ): for i in range ( k + 1 , n ): print ( \"=\" * 30 ) print ( \"Eliminasi ke-\" , k + i ) faktor = a [ i , k ] / a [ k , k ] for j in range ( k , n ): a [ i , j ] = a [ i , j ] - faktor * a [ k , j ] print ( \"Matrix a \\n \" , a ) print ( \"Matrix b \\n \" , b ) # Back x [ n - 1 ] = b [ n - 1 ] / a [ n - 1 , n - 1 ] for i in range ( n - 2 , - 1 , - 1 ): sum_ = b [ i ] for j in range ( i + 1 , n ): sum_ -= a [ i , j ] * x [ j ] x [ i ] = sum_ / a [ i , i ] print ( \"=\" * 30 ) print ( \"Solusi Persamaan 3 Variabel \\n \" ) print ( x ) Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ============================== Eliminasi ke- 1 Matrix a [[ 5. 2. 10. ] [ 0. -2.4 3. ] [ 0. 0. 3. ]] Matrix b [ 9. 20. 10.] ============================== Eliminasi ke- 2 Matrix a [[ 5. 2. 10. ] [ 0. -2.4 3. ] [ 0. 0. 3. ]] Matrix b [ 9. 20. 10.] ============================== Eliminasi ke- 3 Matrix a [[ 5. 2. 10. ] [ 0. -2.4 3. ] [ 0. 0. 3. ]] Matrix b [ 9. 20. 10.] ============================== Solusi Persamaan 3 Variabel [-3.2 -4.16666667 3.33333333] Metode Jacobi Kode Misalkan ini adalah persamaan yang akan dicari \\[ \\displaylines{ \ud835\udc4e+2\ud835\udc4f+3\ud835\udc50=9 \\\\ 5\ud835\udc4e+2\ud835\udc4f+10\ud835\udc50=20 \\\\ \ud835\udc4e\u22122\ud835\udc4f+5\ud835\udc50=10 \\\\ } \\] Susun berdasarkan persamaan diagonal yang paling besar \\[ \\displaylines{ 3a+b+c = 9 \\\\ 5a+10b+2c = 20 \\\\ a+2b+5c = 10 \\\\ } \\] swap dengan persamaan b \\[ \\displaylines{ \ud835\udc4e=(\u22122\ud835\udc4f\u2212\ud835\udc50+9)/3 \\\\ \ud835\udc4f=(\u22125\ud835\udc4e\u22122\ud835\udc50+20)/10 \\\\ \ud835\udc50=(\u2212\ud835\udc4e+2\ud835\udc4f+10)/5 \\\\ } \\] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 f1 = lambda a , b , c : ( - 2 * b - c + 9 ) / 3 f2 = lambda a , b , c : ( - 5 * a - 2 * c + 20 ) / 10 f3 = lambda a , b , c : ( - a + 2 * b + 10 ) / 5 # Inisialisasi x0 = 0 y0 = 0 z0 = 0 count = 1 # Toleransi error e = 0.001 print ( ' \\n Count \\t a \\t b \\t c \\n ' ) condition = True while condition : x1 = f1 ( x0 , y0 , z0 ) y1 = f2 ( x0 , y0 , z0 ) z1 = f3 ( x0 , y0 , z0 ) print ( ' %d \\t %0.4f \\t %0.4f \\t %0.4f \\n ' % ( count , x1 , y1 , z1 )) e1 = abs ( x0 - x1 ) e2 = abs ( y0 - y1 ) e3 = abs ( z0 - z1 ) count += 1 x0 = x1 y0 = y1 z0 = z1 condition = e1 > e and e2 > e and e3 > e print ( ' \\n Solution: a = %0.3f , b = %0.3f and c = %0.3f \\n ' % ( x1 , y1 , z1 )) Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Count a b c 1 3.0000 2.0000 2.0000 2 1.0000 0.1000 2.2000 3 2.2000 1.0600 1.8400 4 1.6800 0.5320 1.9840 5 1.9840 0.7632 1.8768 6 1.8656 0.6326 1.9085 7 1.9421 0.6855 1.8799 8 1.9164 0.6530 1.8858 9 1.9361 0.6647 1.8779 10 1.9309 0.6564 1.8786 Solution: a = 1.931, b = 0.656 and c = 1.879 Metode Gauss Siedel Kode Misalkan ini adalah persamaan yang akan dicari \\[ \\displaylines{ \ud835\udc4e+2\ud835\udc4f+3\ud835\udc50=9 \\\\ 5\ud835\udc4e+2\ud835\udc4f+10\ud835\udc50=20 \\\\ \ud835\udc4e\u22122\ud835\udc4f+5\ud835\udc50=10 \\\\ } \\] Susun berdasarkan persamaan diagonal yang paling besar \\[ \\displaylines{ 3a+b+c = 9 \\\\ 5a+10b+2c = 20 \\\\ a+2b+5c = 10 \\\\ } \\] swap dengan persamaan b \\[ \\displaylines{ \ud835\udc4e=(\u22122\ud835\udc4f\u2212\ud835\udc50+9)/3 \\\\ \ud835\udc4f=(\u22125\ud835\udc4e\u22122\ud835\udc50+20)/10 \\\\ \ud835\udc50=(\u2212\ud835\udc4e+2\ud835\udc4f+10)/5 \\\\ } \\] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 f1 = lambda a , b , c : ( - 2 * b - c + 9 ) / 3 f2 = lambda a , b , c : ( - 5 * a - 2 * c + 20 ) / 10 f3 = lambda a , b , c : ( - a + 2 * b + 10 ) / 5 # Inisialisasi x0 = 0 y0 = 0 z0 = 0 count = 1 # Toleransi error e = 0.001 print ( ' \\n Count \\t a \\t b \\t c \\n ' ) condition = True while condition : x1 = f1 ( x0 , y0 , z0 ) y1 = f2 ( x1 , y0 , z0 ) z1 = f3 ( x1 , y1 , z0 ) print ( ' %d \\t %0.4f \\t %0.4f \\t %0.4f \\n ' % ( count , x1 , y1 , z1 )) e1 = abs ( x0 - x1 ) e2 = abs ( y0 - y1 ) e3 = abs ( z0 - z1 ) count += 1 x0 = x1 y0 = y1 z0 = z1 condition = e1 > e and e2 > e and e3 > e print ( ' \\n Solution: a = %0.3f , b = %0.3f and c = %0.3f \\n ' % ( x1 , y1 , z1 )) Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Count a b c 1 3.0000 0.5000 1.6000 2 2.1333 0.6133 1.8187 3 1.9849 0.6438 1.8606 4 1.9506 0.6526 1.8709 5 1.9413 0.6552 1.8738 6 1.9386 0.6559 1.8746 Solution: a = 1.939, b = 0.656 and c = 1.875","title":"Kode"},{"location":"sistem-persamaan-linear/3.%20kode/#metode-penyelesaian-spl-numerik","text":"","title":"Metode Penyelesaian SPL Numerik"},{"location":"sistem-persamaan-linear/3.%20kode/#metode-eliminasi-gauss","text":"","title":"Metode Eliminasi Gauss"},{"location":"sistem-persamaan-linear/3.%20kode/#kode","text":"Misalkan ini adalah persamaan yang akan dicari \\[ \\displaylines{ \ud835\udc4e+2\ud835\udc4f+3\ud835\udc50=9 \\\\ 5\ud835\udc4e+2\ud835\udc4f+10\ud835\udc50=20 \\\\ \ud835\udc4e\u22122\ud835\udc4f+5\ud835\udc50=10 } \\] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 matrix_a = [ [ 1 , 2 , 3 ], [ 5 , 2 , 10 ], [ 1 , - 2 , 5 ] ] matrix_b = [ 9 , 20 , 10 ] import numpy from numpy import array , zeros a = array ( matrix_a , float ) b = array ( matrix_b , float ) n = len ( b ) x = zeros ( n , float ) # Forward for k in range ( n ): for i in range ( k + 1 , n ): print ( \"=\" * 30 ) print ( \"Eliminasi ke-\" , k + i ) faktor = a [ i , k ] / a [ k , k ] for j in range ( k , n ): a [ i , j ] = a [ i , j ] - faktor * a [ k , j ] print ( \"Matrix a \\n \" , a ) print ( \"Matrix b \\n \" , b ) # Back x [ n - 1 ] = b [ n - 1 ] / a [ n - 1 , n - 1 ] for i in range ( n - 2 , - 1 , - 1 ): sum_ = b [ i ] for j in range ( i + 1 , n ): sum_ -= a [ i , j ] * x [ j ] x [ i ] = sum_ / a [ i , i ] print ( \"=\" * 30 ) print ( \"Solusi Persamaan 3 Variabel \\n \" ) print ( x )","title":"Kode"},{"location":"sistem-persamaan-linear/3.%20kode/#output","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ============================== Eliminasi ke- 1 Matrix a [[ 5. 2. 10. ] [ 0. -2.4 3. ] [ 0. 0. 3. ]] Matrix b [ 9. 20. 10.] ============================== Eliminasi ke- 2 Matrix a [[ 5. 2. 10. ] [ 0. -2.4 3. ] [ 0. 0. 3. ]] Matrix b [ 9. 20. 10.] ============================== Eliminasi ke- 3 Matrix a [[ 5. 2. 10. ] [ 0. -2.4 3. ] [ 0. 0. 3. ]] Matrix b [ 9. 20. 10.] ============================== Solusi Persamaan 3 Variabel [-3.2 -4.16666667 3.33333333]","title":"Output"},{"location":"sistem-persamaan-linear/3.%20kode/#metode-jacobi","text":"","title":"Metode Jacobi"},{"location":"sistem-persamaan-linear/3.%20kode/#kode_1","text":"Misalkan ini adalah persamaan yang akan dicari \\[ \\displaylines{ \ud835\udc4e+2\ud835\udc4f+3\ud835\udc50=9 \\\\ 5\ud835\udc4e+2\ud835\udc4f+10\ud835\udc50=20 \\\\ \ud835\udc4e\u22122\ud835\udc4f+5\ud835\udc50=10 \\\\ } \\] Susun berdasarkan persamaan diagonal yang paling besar \\[ \\displaylines{ 3a+b+c = 9 \\\\ 5a+10b+2c = 20 \\\\ a+2b+5c = 10 \\\\ } \\] swap dengan persamaan b \\[ \\displaylines{ \ud835\udc4e=(\u22122\ud835\udc4f\u2212\ud835\udc50+9)/3 \\\\ \ud835\udc4f=(\u22125\ud835\udc4e\u22122\ud835\udc50+20)/10 \\\\ \ud835\udc50=(\u2212\ud835\udc4e+2\ud835\udc4f+10)/5 \\\\ } \\] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 f1 = lambda a , b , c : ( - 2 * b - c + 9 ) / 3 f2 = lambda a , b , c : ( - 5 * a - 2 * c + 20 ) / 10 f3 = lambda a , b , c : ( - a + 2 * b + 10 ) / 5 # Inisialisasi x0 = 0 y0 = 0 z0 = 0 count = 1 # Toleransi error e = 0.001 print ( ' \\n Count \\t a \\t b \\t c \\n ' ) condition = True while condition : x1 = f1 ( x0 , y0 , z0 ) y1 = f2 ( x0 , y0 , z0 ) z1 = f3 ( x0 , y0 , z0 ) print ( ' %d \\t %0.4f \\t %0.4f \\t %0.4f \\n ' % ( count , x1 , y1 , z1 )) e1 = abs ( x0 - x1 ) e2 = abs ( y0 - y1 ) e3 = abs ( z0 - z1 ) count += 1 x0 = x1 y0 = y1 z0 = z1 condition = e1 > e and e2 > e and e3 > e print ( ' \\n Solution: a = %0.3f , b = %0.3f and c = %0.3f \\n ' % ( x1 , y1 , z1 ))","title":"Kode"},{"location":"sistem-persamaan-linear/3.%20kode/#output_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Count a b c 1 3.0000 2.0000 2.0000 2 1.0000 0.1000 2.2000 3 2.2000 1.0600 1.8400 4 1.6800 0.5320 1.9840 5 1.9840 0.7632 1.8768 6 1.8656 0.6326 1.9085 7 1.9421 0.6855 1.8799 8 1.9164 0.6530 1.8858 9 1.9361 0.6647 1.8779 10 1.9309 0.6564 1.8786 Solution: a = 1.931, b = 0.656 and c = 1.879","title":"Output"},{"location":"sistem-persamaan-linear/3.%20kode/#metode-gauss-siedel","text":"","title":"Metode Gauss Siedel"},{"location":"sistem-persamaan-linear/3.%20kode/#kode_2","text":"Misalkan ini adalah persamaan yang akan dicari \\[ \\displaylines{ \ud835\udc4e+2\ud835\udc4f+3\ud835\udc50=9 \\\\ 5\ud835\udc4e+2\ud835\udc4f+10\ud835\udc50=20 \\\\ \ud835\udc4e\u22122\ud835\udc4f+5\ud835\udc50=10 \\\\ } \\] Susun berdasarkan persamaan diagonal yang paling besar \\[ \\displaylines{ 3a+b+c = 9 \\\\ 5a+10b+2c = 20 \\\\ a+2b+5c = 10 \\\\ } \\] swap dengan persamaan b \\[ \\displaylines{ \ud835\udc4e=(\u22122\ud835\udc4f\u2212\ud835\udc50+9)/3 \\\\ \ud835\udc4f=(\u22125\ud835\udc4e\u22122\ud835\udc50+20)/10 \\\\ \ud835\udc50=(\u2212\ud835\udc4e+2\ud835\udc4f+10)/5 \\\\ } \\] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 f1 = lambda a , b , c : ( - 2 * b - c + 9 ) / 3 f2 = lambda a , b , c : ( - 5 * a - 2 * c + 20 ) / 10 f3 = lambda a , b , c : ( - a + 2 * b + 10 ) / 5 # Inisialisasi x0 = 0 y0 = 0 z0 = 0 count = 1 # Toleransi error e = 0.001 print ( ' \\n Count \\t a \\t b \\t c \\n ' ) condition = True while condition : x1 = f1 ( x0 , y0 , z0 ) y1 = f2 ( x1 , y0 , z0 ) z1 = f3 ( x1 , y1 , z0 ) print ( ' %d \\t %0.4f \\t %0.4f \\t %0.4f \\n ' % ( count , x1 , y1 , z1 )) e1 = abs ( x0 - x1 ) e2 = abs ( y0 - y1 ) e3 = abs ( z0 - z1 ) count += 1 x0 = x1 y0 = y1 z0 = z1 condition = e1 > e and e2 > e and e3 > e print ( ' \\n Solution: a = %0.3f , b = %0.3f and c = %0.3f \\n ' % ( x1 , y1 , z1 ))","title":"Kode"},{"location":"sistem-persamaan-linear/3.%20kode/#output_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Count a b c 1 3.0000 0.5000 1.6000 2 2.1333 0.6133 1.8187 3 1.9849 0.6438 1.8606 4 1.9506 0.6526 1.8709 5 1.9413 0.6552 1.8738 6 1.9386 0.6559 1.8746 Solution: a = 1.939, b = 0.656 and c = 1.875","title":"Output"},{"location":"turunan-numerik/1.%20teori/","text":"Teori Turunan Turunan / differensial adalah suatu cara pengukuran terhadap perubahan yang terjadi pada fungsi yang diakibatkan oleh perubahan suatu variabel; contohnya perbedaan antara kecepatan dan waktu, garis singgung, dan sebagainya. 1 Turunan dapat dihitung menggunakan konsep limit yang dapat didefinisikan dengan rumus di bawah ini, \\[ f'(x) = \\lim_{h \\to 0} (\\frac{f(x+h)-f(x)}{h}) \\] Dimana v fungsi dengan satu variabel bebas, dan u fungsi dengan lebih dari satu variabel bebas. Turunan dapat didefinisikan dengan menambahkan tanda petik pada fungsi seperti, $$ f', f'', f''', ... $$ Ketika fungsi f(x) tidak diketahui secara explisit dan sulit untuk dihitung maka kita dapat menggunakan pencarian dengan turunan numerik. Turunan Numerik Turunan Numerik merupakan salah satu metode yang digunakan untuk mencari turunan dengan nilai yang tidak dapat dihitung secara manual dikarenakan bentuknya yang rumit dan banyak sekali turunannya. 2 Terdapat 3 pendekatan yang digunakan untuk mencari turunan numerik antara lain: Hampiran Selisih Maju Hampiran Selisih Mundur Hampiran Selisih Pusat Dimana penurunan rumus Turunan dapat dihitung dengan menggunakan metode Deret Taylor Polinom Interpolasi Penggunaan turunan numerik dapat digunakan untuk mencari edge pada pengolahan citra sebuah gambar atau cctv secara realtime. Pembahasan mengenai algoritma dan kode dibahas pada halaman berikutnya Referensi Wikipedia Turunan \u21a9 Materi Kuliah Komputasi Numerik ITB Prof. Rinaldi Munir \u21a9","title":"Teori"},{"location":"turunan-numerik/1.%20teori/#teori","text":"","title":"Teori"},{"location":"turunan-numerik/1.%20teori/#turunan","text":"Turunan / differensial adalah suatu cara pengukuran terhadap perubahan yang terjadi pada fungsi yang diakibatkan oleh perubahan suatu variabel; contohnya perbedaan antara kecepatan dan waktu, garis singgung, dan sebagainya. 1 Turunan dapat dihitung menggunakan konsep limit yang dapat didefinisikan dengan rumus di bawah ini, \\[ f'(x) = \\lim_{h \\to 0} (\\frac{f(x+h)-f(x)}{h}) \\] Dimana v fungsi dengan satu variabel bebas, dan u fungsi dengan lebih dari satu variabel bebas. Turunan dapat didefinisikan dengan menambahkan tanda petik pada fungsi seperti, $$ f', f'', f''', ... $$ Ketika fungsi f(x) tidak diketahui secara explisit dan sulit untuk dihitung maka kita dapat menggunakan pencarian dengan turunan numerik.","title":"Turunan"},{"location":"turunan-numerik/1.%20teori/#turunan-numerik","text":"Turunan Numerik merupakan salah satu metode yang digunakan untuk mencari turunan dengan nilai yang tidak dapat dihitung secara manual dikarenakan bentuknya yang rumit dan banyak sekali turunannya. 2 Terdapat 3 pendekatan yang digunakan untuk mencari turunan numerik antara lain: Hampiran Selisih Maju Hampiran Selisih Mundur Hampiran Selisih Pusat Dimana penurunan rumus Turunan dapat dihitung dengan menggunakan metode Deret Taylor Polinom Interpolasi Penggunaan turunan numerik dapat digunakan untuk mencari edge pada pengolahan citra sebuah gambar atau cctv secara realtime. Pembahasan mengenai algoritma dan kode dibahas pada halaman berikutnya","title":"Turunan Numerik"},{"location":"turunan-numerik/1.%20teori/#referensi","text":"Wikipedia Turunan \u21a9 Materi Kuliah Komputasi Numerik ITB Prof. Rinaldi Munir \u21a9","title":"Referensi"},{"location":"turunan-numerik/2.%20algoritma/","text":"Algoritma Hampiran Selisih Maju Hampiran selisih maju mencari turunan yaitu mencari kemiringan garis (gradien) dengan mengambil selisih yang ada di depannya yang ditunjukkan pada gambar di bawah ini 1 dimana x0 - x1 dapat diganti dengan h \\[ (\\frac{y_1-y_0}{x_0-x_1}) = (\\frac{f_1-f_0}{h}) \\] Rumus Dasar \\[ f'(x_0) = (\\frac{f(x_o+h)-f(x_0)}{h}) = (\\frac{f_1-f_0}{h}) \\] h -> 0 (h mendekati 0) agar error relatifnya kecil juga, untuk mencari errornya dapat dilakukan dengan menghitung seperti rumus di bawah ini, yaitu melakukan pembagian antara turunan eksak (sebenarnya) dengan turunan maju \\[ E(f) = -(\\frac{1}{2})hf'(x) \\] Algoritma Deret Taylor Menjabarkan turunan sesuai dengan deret taylor, dimana diketahui bahwa rumus dasar dari deret taylor adalah seperti ini \\[ \\sum_{k=0}^\\infty \\frac{f^{(n)}(a)}{n!} (x-a)^n \\] Sehingga untuk mencari hampiran selisih maju dengan deret taylor akan menjadi seperti ini, \\[ f(x_{i+1}) = f(x_i) + \\frac{x_{i+1}-x_i}{1!} f'(x_i) + \\frac{(x_{i+1}-x_i)^2}{2!} f''(x_i)+.. \\] Rumus di atas apabila diteruskan akan mendapatkan hasil seperti berikut, \\[ O(h) = h/2 f'' (t), x_i<t<x_{i+1} \\] Untuk nilai f di x0 dan x1 menjadi dimana O(h) merupakan orde errornya yang tergantung nilai dari h yang merupakan galat pemotongan dari f sebelumnya. Berikut adalah rumus turunan pertama selisih maju dengan deret taylor \\[ f0' = \\frac{f_1 - f_0}{h} + O(h) \\] Polinom Interpolasi Polinom newton-gregory dapat digunakan untuk menyelesaikan permasalahan turunan numerik yang memiliki titik-titik yang berjarak sama sehingga rumus yang dipakai lebih sederhana dibandingkan polinom interpolasi yang lain. Berikut ini adalah polino newton-gregory untuk selisih maju pada turunan pertama \\[ f'(x_0) = \\frac{3f_0 + 4f_1 - f_2}{2h} \\] Hampiran Selisih Mundur Hampiran selisih mundur mencari turunan yaitu mencari kemiringan garis (gradien) dengan mengambil selisih yang ada di belakangnya / bawahnya yang ditunjukkan pada gambar di bawah ini Rumus Dasar \\[ f'(x_0) = (\\frac{f(x_o)-f(x_0+h)}{h}) = (\\frac{f_0-f_1}{h}) \\] Algoritma Deret Taylor Sama halnya dengan step selisih maju, namun rumus untuk mencari hampiran selisih mundur dengan deret taylor terdapat perubahan yaitu dimulai dari yang terakhir sampai yang awal \\[ f(x_{i-1}) = f(x_i) + \\frac{x_{i+1}-x_i}{1!} f'(x_i) + \\frac{(x_{i+1}-x_i)^2}{2!} f''(x_i)+.. \\] Rumus di atas apabila diteruskan akan mendapatkan hasil seperti berikut, \\[ O(h) = -h/2 f'' (t), x_{i-1}<t<x_{i} \\] Sehingga rumus untuk turunan pertama selisih mundur dengan deret taylor yaitu, $$ f0' = (\\frac{f_0-f_1}{h}) + O(h) $$ Polinom Interpolasi Polinom newton-gregory dapat digunakan untuk menyelesaikan permasalahan turunan numerik yang memiliki titik-titik yang berjarak sama sehingga rumus yang dipakai lebih sederhana dibandingkan polinom interpolasi yang lain. Berikut ini adalah polino newton-gregory untuk selisih maju untuk titik-titik x0 & x-1 pada turunan pertama \\[ f'\\left( x_{0}\\right) =1/h\\left( \\nabla f\\circ \\right) =\\dfrac{f_{0}-f_{-1}}{h} \\] Hampiran Selisih Pusat Hampiran selisih pusat mencari turunan yaitu mencari kemiringan garis (gradien) dengan mencari gabungan dari selisih maju dan selisih mundur. Rumus Dasar \\[ f'(x_0) = (\\frac{f(x_o+h)-f(x_o-h)}{2h}) = (\\frac{f_1-f_{-1}}{2h}) \\] Algoritma Deret Taylor Perhitungan dengan menggunakan rumus mengurangkan persamaan maju dan mundur, yang dapat dilihat dari rumus di bawah ini \\[ f(x_{i+1})-f(x_{i-1}) = 2hf'_i + h^3/3 fi'' + ... \\] Rumus di atas apabila diteruskan akan mendapatkan hasil seperti berikut, \\[ O(h^2) = -h/6 f'''(t), x_{i-1}<t<x_{i+1} \\] Sehingga rumus turunan pertama untuk selisih pusat , $$ f0' = (\\frac{f_1-f_{-1}}{2h}) + O(h^2) $$ Polinom Interpolasi Polinom newton-gregory dapat digunakan untuk menyelesaikan permasalahan turunan numerik yang memiliki titik-titik yang berjarak sama sehingga rumus yang dipakai lebih sederhana dibandingkan polinom interpolasi yang lain. Berikut ini adalah polino newton-gregory untuk selisih pusat untuk titik-titik x-1, x0, dan x1 pada turunan pertama \\[ f'\\left( x_{0}\\right) =\\dfrac{f_{1}-f_{-1}}{2h} \\] Referensi Materi Kuliah Komputasi Numerik ITB Prof. Rinaldi Munir \u21a9","title":"Algoritma"},{"location":"turunan-numerik/2.%20algoritma/#algoritma","text":"","title":"Algoritma"},{"location":"turunan-numerik/2.%20algoritma/#hampiran-selisih-maju","text":"Hampiran selisih maju mencari turunan yaitu mencari kemiringan garis (gradien) dengan mengambil selisih yang ada di depannya yang ditunjukkan pada gambar di bawah ini 1 dimana x0 - x1 dapat diganti dengan h \\[ (\\frac{y_1-y_0}{x_0-x_1}) = (\\frac{f_1-f_0}{h}) \\]","title":"Hampiran Selisih Maju"},{"location":"turunan-numerik/2.%20algoritma/#rumus-dasar","text":"\\[ f'(x_0) = (\\frac{f(x_o+h)-f(x_0)}{h}) = (\\frac{f_1-f_0}{h}) \\] h -> 0 (h mendekati 0) agar error relatifnya kecil juga, untuk mencari errornya dapat dilakukan dengan menghitung seperti rumus di bawah ini, yaitu melakukan pembagian antara turunan eksak (sebenarnya) dengan turunan maju \\[ E(f) = -(\\frac{1}{2})hf'(x) \\]","title":"Rumus Dasar"},{"location":"turunan-numerik/2.%20algoritma/#algoritma_1","text":"","title":"Algoritma"},{"location":"turunan-numerik/2.%20algoritma/#deret-taylor","text":"Menjabarkan turunan sesuai dengan deret taylor, dimana diketahui bahwa rumus dasar dari deret taylor adalah seperti ini \\[ \\sum_{k=0}^\\infty \\frac{f^{(n)}(a)}{n!} (x-a)^n \\] Sehingga untuk mencari hampiran selisih maju dengan deret taylor akan menjadi seperti ini, \\[ f(x_{i+1}) = f(x_i) + \\frac{x_{i+1}-x_i}{1!} f'(x_i) + \\frac{(x_{i+1}-x_i)^2}{2!} f''(x_i)+.. \\] Rumus di atas apabila diteruskan akan mendapatkan hasil seperti berikut, \\[ O(h) = h/2 f'' (t), x_i<t<x_{i+1} \\] Untuk nilai f di x0 dan x1 menjadi dimana O(h) merupakan orde errornya yang tergantung nilai dari h yang merupakan galat pemotongan dari f sebelumnya. Berikut adalah rumus turunan pertama selisih maju dengan deret taylor \\[ f0' = \\frac{f_1 - f_0}{h} + O(h) \\]","title":"Deret Taylor"},{"location":"turunan-numerik/2.%20algoritma/#polinom-interpolasi","text":"Polinom newton-gregory dapat digunakan untuk menyelesaikan permasalahan turunan numerik yang memiliki titik-titik yang berjarak sama sehingga rumus yang dipakai lebih sederhana dibandingkan polinom interpolasi yang lain. Berikut ini adalah polino newton-gregory untuk selisih maju pada turunan pertama \\[ f'(x_0) = \\frac{3f_0 + 4f_1 - f_2}{2h} \\]","title":"Polinom Interpolasi"},{"location":"turunan-numerik/2.%20algoritma/#hampiran-selisih-mundur","text":"Hampiran selisih mundur mencari turunan yaitu mencari kemiringan garis (gradien) dengan mengambil selisih yang ada di belakangnya / bawahnya yang ditunjukkan pada gambar di bawah ini","title":"Hampiran Selisih Mundur"},{"location":"turunan-numerik/2.%20algoritma/#rumus-dasar_1","text":"\\[ f'(x_0) = (\\frac{f(x_o)-f(x_0+h)}{h}) = (\\frac{f_0-f_1}{h}) \\]","title":"Rumus Dasar"},{"location":"turunan-numerik/2.%20algoritma/#algoritma_2","text":"","title":"Algoritma"},{"location":"turunan-numerik/2.%20algoritma/#deret-taylor_1","text":"Sama halnya dengan step selisih maju, namun rumus untuk mencari hampiran selisih mundur dengan deret taylor terdapat perubahan yaitu dimulai dari yang terakhir sampai yang awal \\[ f(x_{i-1}) = f(x_i) + \\frac{x_{i+1}-x_i}{1!} f'(x_i) + \\frac{(x_{i+1}-x_i)^2}{2!} f''(x_i)+.. \\] Rumus di atas apabila diteruskan akan mendapatkan hasil seperti berikut, \\[ O(h) = -h/2 f'' (t), x_{i-1}<t<x_{i} \\] Sehingga rumus untuk turunan pertama selisih mundur dengan deret taylor yaitu, $$ f0' = (\\frac{f_0-f_1}{h}) + O(h) $$","title":"Deret Taylor"},{"location":"turunan-numerik/2.%20algoritma/#polinom-interpolasi_1","text":"Polinom newton-gregory dapat digunakan untuk menyelesaikan permasalahan turunan numerik yang memiliki titik-titik yang berjarak sama sehingga rumus yang dipakai lebih sederhana dibandingkan polinom interpolasi yang lain. Berikut ini adalah polino newton-gregory untuk selisih maju untuk titik-titik x0 & x-1 pada turunan pertama \\[ f'\\left( x_{0}\\right) =1/h\\left( \\nabla f\\circ \\right) =\\dfrac{f_{0}-f_{-1}}{h} \\]","title":"Polinom Interpolasi"},{"location":"turunan-numerik/2.%20algoritma/#hampiran-selisih-pusat","text":"Hampiran selisih pusat mencari turunan yaitu mencari kemiringan garis (gradien) dengan mencari gabungan dari selisih maju dan selisih mundur.","title":"Hampiran Selisih Pusat"},{"location":"turunan-numerik/2.%20algoritma/#rumus-dasar_2","text":"\\[ f'(x_0) = (\\frac{f(x_o+h)-f(x_o-h)}{2h}) = (\\frac{f_1-f_{-1}}{2h}) \\]","title":"Rumus Dasar"},{"location":"turunan-numerik/2.%20algoritma/#algoritma_3","text":"","title":"Algoritma"},{"location":"turunan-numerik/2.%20algoritma/#deret-taylor_2","text":"Perhitungan dengan menggunakan rumus mengurangkan persamaan maju dan mundur, yang dapat dilihat dari rumus di bawah ini \\[ f(x_{i+1})-f(x_{i-1}) = 2hf'_i + h^3/3 fi'' + ... \\] Rumus di atas apabila diteruskan akan mendapatkan hasil seperti berikut, \\[ O(h^2) = -h/6 f'''(t), x_{i-1}<t<x_{i+1} \\] Sehingga rumus turunan pertama untuk selisih pusat , $$ f0' = (\\frac{f_1-f_{-1}}{2h}) + O(h^2) $$","title":"Deret Taylor"},{"location":"turunan-numerik/2.%20algoritma/#polinom-interpolasi_2","text":"Polinom newton-gregory dapat digunakan untuk menyelesaikan permasalahan turunan numerik yang memiliki titik-titik yang berjarak sama sehingga rumus yang dipakai lebih sederhana dibandingkan polinom interpolasi yang lain. Berikut ini adalah polino newton-gregory untuk selisih pusat untuk titik-titik x-1, x0, dan x1 pada turunan pertama \\[ f'\\left( x_{0}\\right) =\\dfrac{f_{1}-f_{-1}}{2h} \\]","title":"Polinom Interpolasi"},{"location":"turunan-numerik/2.%20algoritma/#referensi","text":"Materi Kuliah Komputasi Numerik ITB Prof. Rinaldi Munir \u21a9","title":"Referensi"},{"location":"turunan-numerik/3.%20kode/","text":"Kode Program Diketahui, nilai dari beberapa titik sebagai berikut xi f(xi) 0.1 0.5 0.2 0.88 0.3 1.35 0.4 1.89 0.5 2.51 Soal Tentukan turunan numerik pertama dari xi di 0.1, 0.3, 0.5 dengan rumus dasar di metode numerik Jawaban 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 x = [ 0.1 , 0.2 , 0.3 , 0.4 , 0.5 ] f = [ 0.5 , 0.88 , 1.35 , 1.89 , 2.51 ] def turunan_numerik_1 ( bil ): idx = x . index ( bil ) # hampiran selisih maju if ( idx == 0 ): h = ( x [ idx + 1 ] - x [ idx ]) res = ( f [ idx + 1 ] - f [ idx ]) / h res = round ( res , 2 ) print ( \"f'( {0} ) = f( {1} )-f( {2} ) / ( {3} )\" . format ( x [ idx ], x [ idx + 1 ], x [ idx ], h )) print ( \"Hasil dari f'( {0} ) = {1} \" . format ( x [ idx ], res )) # hampiran selisih mundur elif ( idx == x . index ( x [ - 1 ])): h = ( x [ idx - 1 ] - x [ idx - 2 ]) res = ( f [ idx - 1 ] - f [ idx - 2 ]) / h res = round ( res , 2 ) print ( \"f'( {0} ) = f( {1} )-f( {2} ) / ( {3} )\" . format ( x [ idx ], x [ idx - 1 ], x [ idx - 2 ], h )) print ( \"Hasil dari f'( {0} ) = {1} \" . format ( x [ idx ], res )) # hampiran selisih pusat else : h = ( x [ idx + 1 ] - x [ idx - 1 ]) res = ( f [ idx + 1 ] - f [ idx - 1 ]) / ( 2 * h ) res = round ( res , 2 ) print ( \"f'( {0} ) = f( {1} )-f( {2} ) / ( {3} )\" . format ( x [ idx ], x [ idx + 1 ], x [ idx - 1 ], h )) print ( \"Hasil dari f'( {0} ) = {1} \" . format ( x [ idx ], res )) turunan_numerik_1 ( 0.1 ) print ( \"\" ) turunan_numerik_1 ( 0.3 ) print ( \"\" ) turunan_numerik_1 ( 0.5 ) Hasil Running 1 2 3 4 5 6 7 8 f '(0.1) = f(0.2)-f(0.1) / (0.1) Hasil dari f '(0.1) = 4.9 f '(0.4) = f(0.5)-f(0.3) / (0.2) Hasil dari f '(0.4) = 3.2 f '(0.5) = f(0.4)-f(0.3) / (0.10000000000000003) Hasil dari f '(0.5) = 6.1 Penjelasan xi di 0.1 hanya bisa dihitung dengan hampiran selisih maju xi di 0.3 dapat dihitung dengan pusat (gabungan selisih maju dan mundur) xi di 0.5 hanya bisa dihitung dengan hampiran selisih mundur Saya kurang paham mengimplementasikan metode deret taylor dan polinom dengan python, sehingga saya membuat contoh kode untuk rumus dasar dari masing-masing hampiran selisih","title":"Kode"},{"location":"turunan-numerik/3.%20kode/#kode-program","text":"Diketahui, nilai dari beberapa titik sebagai berikut xi f(xi) 0.1 0.5 0.2 0.88 0.3 1.35 0.4 1.89 0.5 2.51 Soal Tentukan turunan numerik pertama dari xi di 0.1, 0.3, 0.5 dengan rumus dasar di metode numerik Jawaban 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 x = [ 0.1 , 0.2 , 0.3 , 0.4 , 0.5 ] f = [ 0.5 , 0.88 , 1.35 , 1.89 , 2.51 ] def turunan_numerik_1 ( bil ): idx = x . index ( bil ) # hampiran selisih maju if ( idx == 0 ): h = ( x [ idx + 1 ] - x [ idx ]) res = ( f [ idx + 1 ] - f [ idx ]) / h res = round ( res , 2 ) print ( \"f'( {0} ) = f( {1} )-f( {2} ) / ( {3} )\" . format ( x [ idx ], x [ idx + 1 ], x [ idx ], h )) print ( \"Hasil dari f'( {0} ) = {1} \" . format ( x [ idx ], res )) # hampiran selisih mundur elif ( idx == x . index ( x [ - 1 ])): h = ( x [ idx - 1 ] - x [ idx - 2 ]) res = ( f [ idx - 1 ] - f [ idx - 2 ]) / h res = round ( res , 2 ) print ( \"f'( {0} ) = f( {1} )-f( {2} ) / ( {3} )\" . format ( x [ idx ], x [ idx - 1 ], x [ idx - 2 ], h )) print ( \"Hasil dari f'( {0} ) = {1} \" . format ( x [ idx ], res )) # hampiran selisih pusat else : h = ( x [ idx + 1 ] - x [ idx - 1 ]) res = ( f [ idx + 1 ] - f [ idx - 1 ]) / ( 2 * h ) res = round ( res , 2 ) print ( \"f'( {0} ) = f( {1} )-f( {2} ) / ( {3} )\" . format ( x [ idx ], x [ idx + 1 ], x [ idx - 1 ], h )) print ( \"Hasil dari f'( {0} ) = {1} \" . format ( x [ idx ], res )) turunan_numerik_1 ( 0.1 ) print ( \"\" ) turunan_numerik_1 ( 0.3 ) print ( \"\" ) turunan_numerik_1 ( 0.5 ) Hasil Running 1 2 3 4 5 6 7 8 f '(0.1) = f(0.2)-f(0.1) / (0.1) Hasil dari f '(0.1) = 4.9 f '(0.4) = f(0.5)-f(0.3) / (0.2) Hasil dari f '(0.4) = 3.2 f '(0.5) = f(0.4)-f(0.3) / (0.10000000000000003) Hasil dari f '(0.5) = 6.1 Penjelasan xi di 0.1 hanya bisa dihitung dengan hampiran selisih maju xi di 0.3 dapat dihitung dengan pusat (gabungan selisih maju dan mundur) xi di 0.5 hanya bisa dihitung dengan hampiran selisih mundur Saya kurang paham mengimplementasikan metode deret taylor dan polinom dengan python, sehingga saya membuat contoh kode untuk rumus dasar dari masing-masing hampiran selisih","title":"Kode Program"}]}